# Event driven subscription to prevent from polling

openBOS&reg; offers an event-driven mechanism: a subscription allows to subscribe to openBOS&reg; notifications of a change. The big advantage of the notification principle is that the client does need to constantly scan for information on openBOS&reg; (polling) but that openBOS&reg; sends status changes to clients upon their occurance.

Notifications are available for: 
- Changes of values
- Appearance / disappearance of alarms
- User login / logout events
- New firmware update

The subscription consists of a POST operation on the route dedicated to the desired notification. Once the subscription is complete, openBOS&reg; has all the necessary information (type of event, destination address) to send notifications of state changes to its client.
For a certain type of subscription, the customer can associate a filter, making it possible to limit the scope of the events received. 
Technologies available for the notification system are <a href="https://docs.microsoft.com/en-us/aspnet/signalr/overview/getting-started/introduction-to-signalr" target="_blank">SignalR</a> or <a href="https://docs.microsoft.com/en-us/aspnet/overview#webhooks" target="_blank">WebHook</a>. You are able to independently use one or the other technology or both in your implementation.

## SignalR
<a href="https://docs.microsoft.com/en-us/aspnet/signalr/overview/getting-started/introduction-to-signalr" target="_blank">SignalR</a> from ASP.NET is a library for creating server-to-client remote procedure calls.
One advantage of SignalR is that it uses the new websocket transport where available and fallbacks to older transport where necessary.

Activating SignalR is done by creating a hub connection between the client and the server. In C# this would be done as follow:

```csharp
  // Using API from cloud url should be : $"https://api.electrification.ability.abb/buildings/openbos/apiproxy/v1/events?device={BuildingEdgeId}"
  var connection = new HubConnectionBuilder()
      .WithUrl(url, options =>
      {
          options.AccessTokenProvider = () => Task.FromResult(bearerToken);
      })
      .WithAutomaticReconnect()
      .Build();
```

Then the hub connection needs to be initialized with a callback handler where all the events will be trapped once the connection will be started.
Note that the event format will be of type JSON.

```csharp
    // Creates the callback
    connection.On($"{BuildingEdge-id}", (System.Text.Json.JsonElement data) =>
    {
        Console.WriteLine(data);
    });
    // Start the connection
    await connection.StartAsync();
```
After this, you will receive events on the opened hub connection in the callback previously created.

To receive a value of a DatapointInstance you need to subscribe for receiving events from this datapointInstance. This is done by performing a POST on the API endpoint "/api/v1/ontology/datapointsubscription/" and providing the following information:
```json
  {
      "keepAllChanges" : true, // Indicates if several updates of same datapoint occured then they will all be pushed
      "minSendTime" : 0, // minimum time beteen 2 events
      "maxSendTime" : 0, // maximum time between 2 events (if no value change an automatic event is generated by the server)
      "connectionId" : connectionId, // the hub connection id
      "items" : [
        {
            "datapointInstanceId" : <dataPointInstanceId>, // the datapoint instance to subscribe to
            "scanRate" : 1000, // scan rate in milliseconds
            "deadband" : 0 // the amount the value must change from to generate an event
        }
      ],
  };
```
In response to a creation of subscription you will receive an object containing the subscription Id. This is the unique identifier of the subscription inside openBOS&reg;.
In order to change a subscription (add/remove datapoint, change the scan rate) create an HTTP PUT with the exact same object as before but by indicating the subscription Id.
```json
  {
      "keepAllChanges" : true, // Indicates if several updates of same datapoint occured then they will all be pushed
      ...
      "id" : subscriptionId, // the unique subscription id
      "items" : [
        ...
      ],
  };
```

## Webhook
Webhooks are HTTP callbacks called by the server to send notifications to the client.
Webhooks require that the client side  also acts as a server and in this way, accepts incoming calls.

When sending an event through webhook, openBOS&reg; will generate an HTTP POST to the WebhookURL specified in the subscription. The HTTP POST will have a body content including the event data to consume.

To subscribe to a Datapoint value change and specify that instead of signalR you would like to use Webhook,
leave "connectionId" to null and provide  
the endpoint that must be called in "WebhookURL".
To receive a value from a DatapointInstance you can subscribe for receiving events from this datapointInstance. For that you need to POST on the API endpoint 
"/api/v1/ontology/datapointsubscription" and provide the following information:
```json
  {
      "keepAllChanges" : true, // Indicates if several updates of same datapoint occured then they will all be pushed
      "minSendTime" : 0, // minimum time beteen 2 events
      "maxSendTime" : 0, // maximum time between 2 events (if no value change an automatic event is generated by the server)
      "connectionId" : null, // the hub connection id,
      "WebhookURL" : "http://myaddress", // endpoint that will consume the event
      "WebhookRetryCount" : 10, // Number of retries after the webhook subscription is considered as broken
      "WebhookRetryDelay" : 10, // Delay in seconds between 2 retries
      "items" : [
        {
            "datapointInstanceId" : <dataPointInstanceId>, // the datapoint instance to subscribe to
            "scanRate" : 1000, // scan rate in milliseconds
            "deadband" : 0 // the amount the value must change from to generate an event
        }
      ],
  };
```

The format of events received for WebHook or SignalR are exactly the same (See the sample above for SignalR).