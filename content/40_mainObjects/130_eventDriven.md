# Event driven subscription to prevent from polling

openBOS&reg; offers an event-driven mechanism: a subscription allows to subscribe to openBOS&reg; notifications of a change. The big advantage of the notification principle is that the client does need to constantly scan for information on openBOS&reg; (polling) but that openBOS&reg; sends status changes to clients upon their occurance.

Notifications are available for: 
- Changes of values
- Appearance / disappearance of alarms
- User login / logout events
- New firmware update

The subscription consists of a POST operation on the route dedicated to the desired notification. Once the subscription is complete, openBOS&reg; has all the necessary information (type of event, destination address) to send notifications of state changes to its client.
For a certain type of subscription, the customer can associate a filter, making it possible to limit the scope of the events received. 
Technologies available for the notification system are <a href="https://docs.microsoft.com/en-us/aspnet/signalr/overview/getting-started/introduction-to-signalr" target="_blank">SignalR</a> or <a href="https://docs.microsoft.com/en-us/aspnet/overview#webhooks" target="_blank">WebHook</a>. You are able to independently use one or the other technology or both in your implementation.

## SignalR
<a href="https://docs.microsoft.com/en-us/aspnet/signalr/overview/getting-started/introduction-to-signalr" target="_blank">SignalR</a> from ASP.NET is a library for creating server-to-client remote procedure calls.
One advantage of SignalR is that it uses the new websocket transport where available and fallbacks to older transport where necessary.

Activating SignalR is done by creating a hub connection between the client and the server. In C# this would be done as follow:

```csharp
  // Using API from cloud url should be : $"https://api.electrification.ability.abb/buildings/openbos/apiproxy/v1/events?device={BuildingEdgeId}"
  var connection = new HubConnectionBuilder()
      .WithUrl(url, options =>
      {
          options.AccessTokenProvider = () => Task.FromResult(bearerToken);
      })
      .WithAutomaticReconnect()
      .Build();
```

Then the hub connection needs to be initialized with a callback handler where all the events will be trapped once the connection will be started.
Note that the event format will be of type JSON.

```csharp
    // Creates the callback
    connection.On($"{BuildingEdge-id}", (System.Text.Json.JsonElement data) =>
    {
        Console.WriteLine(data);
    });
    // Start the connection
    await connection.StartAsync();
```
After this, you will receive events on the opened hub connection in the callback previously created.

To receive a value of a DatapointInstance you need to subscribe for receiving events from this datapointInstance. This is done by performing a POST on the API endpoint "/api/v1/ontology/datapointinstance/livedata/extended/subscribe" and providing the following information:
```json
  {
      "keepAllChanges" : true, // Indicates if several updates of same datapoint occured then they will all be pushed
      "minSendTime" : 0, // minimum time beteen 2 events
      "maxSendTime" : 0, // maximum time between 2 events (if no value change an automatic event is generated by the server)
      "connectionId" : connectionId // the hub connection id
  };
```

In response to a creation of subscription you will receive an object containing the subscription Id. This is the unique identifier of the subscription inside openBOS&reg;.

## Webhook
Webhooks are HTTP callbacks called by the server to send notifications to the client.
Webhooks require that the client side  also acts as a server and in this way, accepts incoming calls.

When sending an event through webhook, openBOS&reg; will generate an HTTP POST to the WebhookURL specified in the subscription. The HTTP POST will have a body content including the event data to consume.

To subscribe to a Datapoint value change and specify that instead of signalR you would like to use Webhook, leave "connectionId" to null and provide  
the endpoint that must be called in "WebhookURL".

To receive a value from a DatapointInstance you can subscribe for receiving events from this datapointInstance. 
For that you need to POST on the API endpoint "api/v1/ontology/datapointinstance/livedata/extended/subscribe" and provide the following information:
```json
  {
      "keepAllChanges" : true, // Indicates if several updates of same datapoint occured then they will all be pushed
      "minSendTime" : 0, // minimum time beteen 2 events
      "maxSendTime" : 0, // maximum time between 2 events (if no value change an automatic event is generated by the server)
      "connectionId" : null, // the hub connection id,
      "WebhookURL" : "http://myaddress", // endpoint that will consume the event
      "WebhookRetryCount" : 10, // Number of retries after the webhook subscription is considered as broken
      "WebhookRetryDelay" : 10, // Delay in seconds between 2 retries
  };
```

The format of events received for WebHook or SignalR are exactly the same (See the sample above for SignalR).

# Adding a datapoint to a subscription


In order to add datapoint in subscription
PUT on the API endpoint "api/v1/ontology/datapointinstance/livedata/extended/subscribe/{subscriptionId}" 
where subscriptionId is the id of the subscription retrieved previously.
In the PUT body set in the items property the identification of the dataopint to be read.

```json
{
  "ignoreErrors": "true",
  "items": [
    { // for a value to be raed directly using the prtocol arguments
      "scanRate": 10, // scan rate of the datapoint
      "deadBand": 1, // deadband
      "datapointClientId": clientId, // a unique identifier of the datapoint for the client side
      "datapoint": {
        "type": "protocolargumentsonly",
        "networkId": networkId, // the identifier of the network where to read
        "protocolArguments": {
          "deviceid": 1,
          "objectinstance": 1,
          "objecttype": "analog-value",
          "propertyidentifier": "present-value"
        }
      }
    },
    { // for a value coming from a datapointInstance attached to an asset or a zone
      "scanRate": 10, // scan rate of the datapoint
      "deadBand": 1, // deadband
      "datapointClientId": clientId, // a unique identifier of the datapoint for the client side
      "datapoint": {
        "type": "datapointinstance",
        "id" : datapointInstanceId
      }
    },
    { // for a value coming from a datapoint that has been scanned/declared in a network organization
      "scanRate": 10, // scan rate of the datapoint
      "deadBand": 1, // deadband
      "datapointClientId": clientId, // a unique identifier of the datapoint for the client side
      "datapoint": {
        "type": "busdatapoint",
        "networkId": networkId,
        "busDatapointId": busDatapointId
      }
    }

  ]
}```
